import { useSortable } from '@dnd-kit/sortable';
import React, { useEffect, useState, useCallback, useRef, useMemo } from 'react';
import { useTable, useSortBy, usePagination, useFilters } from 'react-table';
import { useDrag, useDrop, DndProvider } from 'react-dnd';
import { HTML5Backend } from 'react-dnd-html5-backend';
import { DndContext, closestCenter, useSensor, useSensors, MouseSensor, KeyboardSensor, TouchSensor } from '@dnd-kit/core';
import { restrictToVerticalAxis } from '@dnd-kit/modifiers';
import { SortableContext, verticalListSortingStrategy, arrayMove } from '@dnd-kit/sortable';
import '../styles/UsersTable.css';

// –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∞ –¥–ª—è –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏—è —Å—Ç—Ä–æ–∫
const DraggableRow = ({ row }) => {
  const { attributes, listeners, setNodeRef, transform, transition, isDragging } = useSortable({
    id: row.original.userId,
  });

  const style = {
    transform: `translateY(${transform ? transform.y : 0}px)`,
    transition,
    opacity: isDragging ? 0.8 : 1,
  };

  return (
    <tr ref={setNodeRef} style={style} {...attributes} {...listeners}>
      {row.cells.map((cell) => (
        <td {...cell.getCellProps()}>{cell.render('Cell')}</td>
      ))}
    </tr>
  );
};

// –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∞ DraggableHeader
const DraggableHeader = ({ column, moveColumn, index, handleResizeStart, columnWidths, isTarget }) => {
  const ref = React.useRef(null);

  const [, drop] = useDrop({
    accept: 'column',
    hover(item, monitor) {
      if (!ref.current) return;

      const dragIndex = item.index;
      const hoverIndex = index;

      if (dragIndex === hoverIndex) return;

      const hoverBoundingRect = ref.current.getBoundingClientRect();
      const hoverMiddleX = (hoverBoundingRect.right - hoverBoundingRect.left) / 2;
      const mousePosition = monitor.getClientOffset();
      const hoverClientX = mousePosition.x - hoverBoundingRect.left;

      if (dragIndex < hoverIndex && hoverClientX < hoverMiddleX) return;
      if (dragIndex > hoverIndex && hoverClientX > hoverMiddleX) return;

      moveColumn(dragIndex, hoverIndex);
      item.index = hoverIndex;
    },
    collect: (monitor) => ({
      isOver: !!monitor.isOver(),
    }),
  });

  const [{ isDragging }, drag] = useDrag({
    type: 'column',
    item: { type: 'column', index },
    collect: (monitor) => ({
      isDragging: monitor.isDragging(),
    }),
  });

  drag(drop(ref));

  return (
    <th
      ref={ref}
      className={`draggable-header ${isTarget ? 'target-column' : ''}`}
      style={{
        opacity: isDragging ? 0.5 : 1,
        cursor: 'move',
        width: columnWidths[index] || 100,
        position: 'relative',
        border: isTarget ? '2px dashed #00f' : '', // –ü–æ–¥—Å–≤–µ—Ç–∫–∞ –±—É–¥—É—â–µ–≥–æ –º–µ—Å—Ç–∞
      }}
    >
      <div className="header-wrapper" style={{ display: 'flex', position: 'relative' }}>
        {column.render('Header')}
        <span {...column.getSortByToggleProps()}>
          {column.isSorted ? (column.isSortedDesc ? ' üîΩ' : ' üîº') : ''}
        </span>
        <div
          className="resize-handle"
          onMouseDown={(e) => handleResizeStart(index, e)}
          style={{
            position: 'absolute',
            right: '-4px', // –°–º–µ—â–∞–µ–º —Ä–∞–∑–¥–µ–ª–∏—Ç–µ–ª—å –∫ –≥—Ä–∞–Ω–∏—Ü–µ
            top: 0,
            width: '8px', // –®–∏—Ä–∏–Ω–∞ —Ä–∞–∑–¥–µ–ª–∏—Ç–µ–ª—è –¥–ª—è —É–¥–æ–±–Ω–æ–≥–æ –∑–∞—Ö–≤–∞—Ç–∞
            height: '100%',
            cursor: 'col-resize',
            zIndex: 10,
            backgroundColor: 'transparent', // –ü—Ä–æ–∑—Ä–∞—á–Ω—ã–π —Ñ–æ–Ω
          }}
        />
      </div>
    </th>
  );
};

// –°–æ–∑–¥–∞–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö
const makeData = (rows = 50) => {
  const statuses = ['Active', 'Inactive', 'Pending'];
  const firstNames = ['John', 'Jane', 'Alice', 'Bob'];
  const lastNames = ['Doe', 'Smith', 'Johnson', 'Brown'];

  return Array.from({ length: rows }, (_, index) => ({
    userId: index + 1,
    firstName: firstNames[Math.floor(Math.random() * firstNames.length)],
    lastName: lastNames[Math.floor(Math.random() * lastNames.length)],
    age: Math.floor(Math.random() * 50) + 20,
    status: statuses[Math.floor(Math.random() * statuses.length)],
  }));
};

// –ì–ª–∞–≤–Ω—ã–π –∫–æ–º–ø–æ–Ω–µ–Ω—Ç IncidentsTable
const IncidentsTable = ({ onIncidentClick, onCreateIncidentClick, isSidebarCollapsed }) => {
  const [incidents, setIncidents] = useState(() => makeData(50)); // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –¥–∞–Ω–Ω—ã—Ö
  const [fields, setFields] = useState([]);
  const [searchQuery, setSearchQuery] = useState('');
  const [visibleFields, setVisibleFields] = useState([]);
  const [columnWidths, setColumnWidths] = useState({});
  const [targetIndex, setTargetIndex] = useState(null); // –î–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è —Ü–µ–ª–µ–≤–æ–≥–æ –∏–Ω–¥–µ–∫—Å–∞ –ø—Ä–∏ –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏–∏
  const [data, setData] = useState(() => makeData(20)); // –î–∞–Ω–Ω—ã–µ –¥–ª—è –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏—è —Å—Ç—Ä–æ–∫

  const resizingColumnRef = useRef(null);
  const startXRef = useRef(0);
  const startWidthRef = useRef(0);

  useEffect(() => {
    fetchFields();
    fetchIncidents();
    const intervalId = setInterval(() => fetchIncidents(searchQuery), 5000);
    return () => clearInterval(intervalId);
  }, [searchQuery]);

  const fetchFields = async () => {
    try {
      const response = await fetch('http://127.0.0.1:5000/api/fields');
      const data = await response.json();
      if (fields.length === 0) {
        setFields(data);
        setVisibleFields(data); // –ò–∑–Ω–∞—á–∞–ª—å–Ω–æ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –≤—Å–µ –ø–æ–ª—è
      }
    } catch (error) {
      console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –ø–æ–ª–µ–π:', error);
    }
  };

  const fetchIncidents = async (query = '') => {
    try {
      const url = query
        ? `http://127.0.0.1:5000/api/search-incidents?query=${query}`
        : 'http://127.0.0.1:5000/api/incidents';
      const response = await fetch(url);
      const data = await response.json();
      setIncidents(data.incidents);
    } catch (error) {
      console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –¥–∞–Ω–Ω—ã—Ö:', error);
    }
  };

  const handleResizeStart = (index, e) => {
    e.preventDefault();
    resizingColumnRef.current = index;
    startXRef.current = e.clientX;
    startWidthRef.current = columnWidths[index] || 100;
    document.addEventListener('mousemove', handleMouseMove);
    document.addEventListener('mouseup', handleMouseUp);
  };

  const handleMouseMove = (e) => {
    if (resizingColumnRef.current === null) return;

    const deltaX = e.clientX - startXRef.current;
    const newWidth = startWidthRef.current + deltaX;

    // –ò—Å–ø–æ–ª—å–∑—É–µ–º requestAnimationFrame –¥–ª—è –ø–ª–∞–≤–Ω–æ–π –∞–Ω–∏–º–∞—Ü–∏–∏
    requestAnimationFrame(() => {
      if (newWidth >= 100) {
        setColumnWidths((prevWidths) => ({
          ...prevWidths,
          [resizingColumnRef.current]: newWidth,
        }));
      }
    });
  };

  const handleMouseUp = () => {
    document.removeEventListener('mousemove', handleMouseMove);
    document.removeEventListener('mouseup', handleMouseUp);
    resizingColumnRef.current = null;
  };

  const moveColumn = useCallback((dragIndex, hoverIndex) => {
    const newFields = [...fields];
    const [movedField] = newFields.splice(dragIndex, 1);
    newFields.splice(hoverIndex, 0, movedField);
    setFields(newFields);
    setTargetIndex(hoverIndex); // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∏–Ω–¥–µ–∫—Å —Ü–µ–ª–µ–≤–æ–≥–æ —Å—Ç–æ–ª–±—Ü–∞
  }, [fields]);

  const columns = useMemo(() => fields.map((field, index) => ({
    Header: field,
    accessor: field,
    Filter: TextFilter,
    isTarget: targetIndex === index,
  })), [fields, targetIndex]);

  const table = useTable(
    {
      columns,
      data: incidents,
      initialState: { pageSize: 10 }, // –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å—Ç—Ä–æ–∫ –Ω–∞ —Å—Ç—Ä–∞–Ω–∏—Ü–µ
    },
    useFilters,
    useSortBy,
    usePagination
  );

  // –°–ø–∏—Å–æ–∫ ID –¥–ª—è –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏—è —Å—Ç—Ä–æ–∫
  const dataIds = useMemo(() => data?.map(({ userId }) => userId), [data]);

  // reorder rows after drag & drop
  function handleDragEnd(event) {
    const { active, over } = event;
    if (active && over && active.id !== over.id) {
      setData((prevData) => {
        const oldIndex = dataIds.indexOf(active.id);
        const newIndex = dataIds.indexOf(over.id);
        return arrayMove(prevData, oldIndex, newIndex);
      });
    }
  }

  const sensors = useSensors(
    useSensor(MouseSensor),
    useSensor(TouchSensor),
    useSensor(KeyboardSensor)
  );

  return (
    <div className={`table-container ${isSidebarCollapsed ? 'sidebar-collapsed' : ''}`}>
      <div className="action-bar">
        <div className="search-container">
          <input
            type="text"
            className="search-input"
            placeholder="–ü–æ–∏—Å–∫..."
            value={searchQuery}
            onChange={(e) => setSearchQuery(e.target.value)}
          />
          <button className="search-button" onClick={() => fetchIncidents(searchQuery)}>
            –ü–æ–∏—Å–∫
          </button>
        </div>
        <button className="action-button" onClick={onCreateIncidentClick}>
          –°–æ–∑–¥–∞—Ç—å –∏–Ω—Ü–∏–¥–µ–Ω—Ç
        </button>
      </div>
      <DndProvider backend={HTML5Backend}>
        <div className="table-wrapper">
          <DndContext
            collisionDetection={closestCenter}
            modifiers={[restrictToVerticalAxis]}
            onDragEnd={handleDragEnd}
            sensors={sensors}
          >
            <table {...table.getTableProps()} className="UserTableClass">
              <thead>
                {table.headerGroups.map((headerGroup) => (
                  <tr {...headerGroup.getHeaderGroupProps()}>
                    {headerGroup.headers.map((column, index) => (
                      <DraggableHeader
                        key={column.id}
                        column={column}
                        index={index}
                        moveColumn={moveColumn}
                        handleResizeStart={handleResizeStart}
                        columnWidths={columnWidths}
                        isTarget={column.isTarget} // –ü–æ–¥—Å–≤–µ—á–∏–≤–∞–µ–º —Ü–µ–ª–µ–≤–æ–π —Å—Ç–æ–ª–±–µ—Ü
                      />
                    ))}
                  </tr>
                ))}
              </thead>
              <SortableContext items={dataIds} strategy={verticalListSortingStrategy}>
                <tbody {...table.getTableBodyProps()}>
                  {table.page.map((row) => {
                    table.prepareRow(row);
                    return (
                      <DraggableRow key={row.id} row={row} />
                    );
                  })}
                </tbody>
              </SortableContext>
            </table>
          </DndContext>
        </div>
        <div className="pagination">
          <button onClick={table.previousPage} disabled={!table.canPreviousPage}>
            {'<'}
          </button>
          <button onClick={table.nextPage} disabled={!table.canNextPage}>
            {'>'}
          </button>
          <select
            value={table.state.pageSize}
            onChange={(e) => table.setPageSize(Number(e.target.value))}
          >
            {[10, 20, 30, 40, 50].map((pageSize) => (
              <option key={pageSize} value={pageSize}>
                –ü–æ–∫–∞–∑–∞—Ç—å {pageSize}
              </option>
            ))}
          </select>
        </div>
      </DndProvider>
    </div>
  );
};

// –ü—Ä–∏–º–µ—Ä —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏ —Ç–µ–∫—Å—Ç–∞
function TextFilter({ column: { filterValue, setFilter } }) {
  return (
    <input
      value={filterValue || ''}
      onChange={(e) => setFilter(e.target.value || undefined)}
      placeholder="–§–∏–ª—å—Ç—Ä..."
    />
  );
}

export default IncidentsTable;
